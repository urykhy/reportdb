#summary how to use a CDB engine in my app?

This article is going to teach about CDB (at least going to exam a test/test-cdb.cpp)

=Part 1, HighLevel Interface=

we define our table:
{{{
    CDB_BEGIN_TABLE(Root)
        CDB_COLUMN(age, unsigned char)
        CDB_COLUMN(city, uint32_t)
        CDB_COLUMN(uid, uint32_t)
    CDB_END_TABLE(Root)
}}}

now we going to use it:

open CDB base:
{{{
        CDB::Create<Root> cdb(fn);
        CDB::Create<Root>::RawDataT id;
}}}
  * fn is a filename
  * id - is a container, we going to collect some data before writing.


fill it:
{{{
        Root::Data d;
        for(uint8_t age = 10; age < 20; age++)
            for (uint32_t city = 100; city < 110; city++)
            {
                uint32_t lead_uid = city*100 + age * 10;
                for (uint32_t uid = 0; uid < 5; uid++)
                {
                    TL::SetArg(d, age, city, uid + lead_uid);
                    id.insert(d);
                }
            }
        cdb.insert(id);
        cdb.close();
}}}
  * `d` is a row variable.


now we can walk around of our data:
{{{
            CDB::Use<Root> uc(fn);
            Root::Narrow narrow;
            Worker2 worker;
            uc.access(narrow, worker);
}}}
  * Narrow is a class to limit rows from processing by Worker.


Worker2 is a
{{{
struct Worker2
    {
        uint32_t calls;
        Worker2() : calls(0) { ;; }
        void operator()(const Root::Accessor& ac, size_t idx)
        {
            calls++;
        }
        uint64_t columns() { return ColumnName_uid; }
    };
}}}

As you notice - we should say to engine which columns we need (`column()` method in Worker). Column names is auto generated by `CDB_COLUMN` macro in form of `ColumnName_*`.

You can use `TL::get<2>(ac.acc).get(idx)` to access a `uid` column in the Worker. (yes, it a bit confusing to access a auto generated `Accessor` internals). `idx` is a row number in the currently decompressed block.

you can use `test/test-tl.cpp` as example.


=Part 2, LowLevel Interface=

This is more complicated way to use CDB, but here we can tune anything!

== Data Types ==

Ok, to start we need to define few data types, which should describe data types we using, and so on:

{{{
  struct Root {
    struct Data;
    struct Accessor ;
  }
  struct Narrow;
  struct Worker;
}}}

  * Root - main structure in CDB, used to define which data db will store.
  * Narrow - is a condition check layer (pass row to worker or not).
  * Worker - report generator.


=== Root::Data ===
{{{
     struct Data {
      uint8_t  age;
      uint8_t  gender;
      uint32_t city;
      uint32_t uid;

      #define CGEN_LESS(a,b) \
        if (a < b ) return true; \
        if (a > b ) return false;

      bool operator<(const Data& right) const {
        CGEN_LESS(age, right.age)
        CGEN_LESS(gender, right.gender)
        CGEN_LESS(city, right.city)
        CGEN_LESS(uid, right.uid)
        return false;
      }
      #undef CGEN_LESS
    };
}}}

this is simple Root::Data variant, so hold a few fields. Note an `operator<` - we need it since data is stored in std::set.


=== Root::Accessor ===

{{{
    struct Accessor {
      CDB::Row<uint8_t> age;
      CDB::Row<uint8_t> gender;
      CDB::Row<uint32_t> city;
      CDB::Row<uint32_t> uid;

      void push_back(const Data& d);
      void open(const std::string& fn, CDB::Direction di, uint64_t columns);
      void write();
      size_t read(uint64_t columns);
      void close();
      bool eof();
    };
}}}

Ok, Accessor is much harder, it used to read and write a CDB, so interface is quite long. CDB::Row<> instances used to represent a CDB columns (yes, names is confusing here).
  * push_back - called by CDB to add a record to database.
  * open - open cdb (di means direction - read/write, and columns used to limit colums we should operate on)
  * write - flush collected (by push_back() calls data to disk)
  * read - read some columns from disk
  * eof - called to check if no more data to process


===  Narrow ===

Really, we don't want to pass every row to worker, say we want to run a report for `gender==0` or something, so Narrow is used to limit rows from handling:

{{{
struct Narrow1 {
    uint64_t columns () const;
    bool operator()(const Root::Accessor& ac, size_t rown) const ;
};
}}}

  * columns - used by engine to find which columns should be fetched from disk for condition-match. (say if we have limit an age to 10, we need to fetch and 'age' column, even if report not need it)
  * operator() - is a entry point for condition checking. here we must decide: will row handled by worker (return true) or not (return false).


=== Worker ===

Is a main report class, usually you will need to make a lot of classes, one per report you want.

{{{
  struct Worker1
  {
     void operator()(const Root::Accessor& ac, size_t idx)
     uint64_t columns()
  };
}}}

Note a columns() method. Worker can ask engine to get specified rows from disk. Every row in this test coded by bit in 64-bit-width unsigned.


= Initial fill =

Now it is a time to load data into db:
{{{
    CDB::Create<Root> cdb(filename);
    CDB::Create<Root>::RawDataT id;
}}}

we need to fill the id container with Root::Data structures, after end - we can pass em to CDB and write to disk:
{{{
    cdb.insert(id);
    cdb.close();
}}}

Please note, CDB supports an `append` operation. so it's possible to make a multiple calls to `insert`, or even open the same file multiple times, and append new data.


= Run a report =

Ok, we have cdb on disk. Now we going to fetch data and make a report:
{{{
      CDB::Use<Root> uc(filename);
      Narrow narrow;
      Worker worker;
      uc.access(narrow, worker);
}}}

to get some actual results, Worker::operator() should count something.

You can use `test/test-cdb.cpp` as example.
